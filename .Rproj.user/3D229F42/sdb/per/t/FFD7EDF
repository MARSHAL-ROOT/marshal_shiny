{
    "collab_server" : "",
    "contents" : "# Guillaume Lobet - Forschungszentrum Julich\n\nshinyServer(\n  \n  function(input, output, clientData, session) {  \n    \n    rs <- reactiveValues(rootsystem = NULL, \n                         dataset = NULL, \n                         plant = NULL,\n                         params = NULL, \n                         litt = NULL, \n                         plot=NULL,\n                         conductivities = NULL,\n                         krs = NULL,\n                         tact = NULL,\n                         soil = NULL,\n                         evol = NULL,\n                         krs_first = NULL,\n                         krs_act = NULL)\n    \n    observe({\n      fileName <- 'www/litterature.txt'\n      litt <- read.table(fileName, sep=\"\\t\", stringsAsFactors = F, header = T)\n      rs$litt <- litt\n      fileName <- 'www/modelparameter'\n      flist <- unique(gsub(\".pparam\", \"\", gsub(\".rparam\", \"\", list.files(fileName))))\n      fl <- litt$name[litt$id %in% flist]\n      updateSelectInput(session, \"dataset\", choices = fl)  \n      \n    })  \n\n    observe({\n      if(is.null(rs$rootsystem)){return()}\n      types <- unique(rs$rootsystem$name)\n      ct_options <- list()\n      sel <- input$choosetype\n      if(length(sel) == 0) sel = types\n      for(ct in types) ct_options[[ct]] <- ct\n      updateSelectInput(session, \"choosetype\", choices = ct_options, selected=sel)       \n      \n    })\n    \n    # Sliders for the root system SUF\n    observe({\n      if(is.null(rs$rootsystem)){return()}\n      sel <- round(quantile(rs$rootsystem$suf, c(.01, .99), na.rm = T), 2)\n      lim <- round(range(rs$rootsystem$suf, na.rm = T), 2)\n      if(lim[1] == -Inf) lim[1] <- sel[1]\n      updateSliderInput(session, \"sufrange\", min=lim[1], max=lim[2], value=c(sel[[1]],sel[[2]]))\n    })\n    \n    # Sliders for the root system potentials\n    observe({\n      if(is.null(rs$rootsystem)){return()}\n      sel <- round(quantile(rs$rootsystem$psi, c(0, 1), na.rm = T), 2)\n      lim <- round(range(rs$rootsystem$psi, na.rm = T), 2)\n      if(lim[1] == -Inf) lim[1] <- sel[1]\n      updateSliderInput(session, \"psirange\", min=lim[1], max=lim[2], value=c(sel[[1]],sel[[2]]))\n    }) \n    \n    # Sliders for the root system axial fluxes\n    observe({\n      if(is.null(rs$rootsystem)){return()}\n      sel <- round(quantile(rs$rootsystem$jxl, c(.01, .99), na.rm = T), 2)\n      lim <- round(range(rs$rootsystem$jxl, na.rm = T), 2)\n      if(lim[1] == -Inf) lim[1] <- sel[1]\n      updateSliderInput(session, \"jxlrange\", min=lim[1], max=lim[2], value=c(sel[[1]],sel[[2]]))\n    })     \n    \n    # Sliders for the root system radial fluxes\n    observe({\n      if(is.null(rs$rootsystem)){return()}\n      sel <- round(quantile(rs$rootsystem$jr, c(.01, .99), na.rm = T), 2)\n      lim <- round(range(rs$rootsystem$jr, na.rm = T), 2)\n      if(lim[1] == -Inf) lim[1] <- sel[1]\n      updateSliderInput(session, \"jrrange\", min=lim[1], max=lim[2], value=c(sel[[1]],sel[[2]]))\n    })     \n    \n    \n    # Get the click inside the soil graph\n    observe({\n      if(is.null(rs$soil)){return()}\n      # Because it's a ggplot2, we don't need to supply xvar or yvar; if this\n      # were a base graphics plot, we'd need those.\n      sel <- nearPoints(rs$soil, input$plot2_click)\n      updateTextInput(session, \"x_input_soil\", value=sel$psi)\n      updateTextInput(session, \"y_input_soil\", value=sel$z)\n      # paste0(sel$order, \" / \", sel$type)\n    }) \n    \n    \n    # Update the simulation with new transpiration values\n    \n    observeEvent(input$updateDemand, {\n\n      rootsystem <- rs$rootsystem\n      \n      hydraulics <- getSUF(rootsystem, rs$conductivities, rs$soil, Psi_collar = input$psiCollar)\n      \n      rootsystem$suf <- as.vector(hydraulics$suf)\n      rootsystem$jr <- as.vector(hydraulics$jr)\n      rootsystem$psi <- as.vector(hydraulics$psi)\n      rootsystem$suf1 <- as.vector(hydraulics$suf1)\n      rootsystem$kx <- hydraulics$kx\n      rootsystem$kr <- hydraulics$kr\n      rootsystem$jxl <- as.vector(hydraulics$jxl)\n      rootsystem$psi_soil <- as.vector(hydraulics$psi_soil)\n      \n      mydata <- rootsystem\n      #mydata$length = sqrt((mydata$x1-mydata$x2)^2 + (mydata$y1-mydata$y2)^2 + (mydata$z1-mydata$z2)^2 )\n      mydata$z1 <- round(mydata$z1, 0)\n      dens2 <- ddply(mydata, .(z1), summarise, root = sum(jr))\n      max <- dens2$z1[dens2$root == max(dens2$root)]\n      \n      rs$rootsystem <- rootsystem\n      rs$tact <- hydraulics$tact\n      rs$krs <- hydraulics$krs\n      rs$evol <- rbind( rs$evol, data.frame(krs = hydraulics$krs, tact = hydraulics$tact, udepth=max))\n    })\n    \n    # Update the simulation with new soil values\n    observeEvent(input$updateSoil, {\n      soil <- rs$soil\n      sel <- nearPoints(soil, input$plot2_click)\n      \n      rootsystem <- rs$rootsystem\n      \n      soil$psi[soil$id == sel$id] <- as.numeric(input$x_input_soil)\n      soil$z[soil$id == sel$id] <- as.numeric(input$y_input_soil)\n      \n      \n      hydraulics <- getSUF(rootsystem, rs$conductivities, soil, Psi_collar = input$psiCollar)\n      \n      rootsystem$suf <- as.vector(hydraulics$suf)\n      rootsystem$jr <- as.vector(hydraulics$jr)\n      rootsystem$psi <- as.vector(hydraulics$psi)\n      rootsystem$suf1 <- as.vector(hydraulics$suf1)\n      rootsystem$kx <- hydraulics$kx\n      rootsystem$kr <- hydraulics$kr\n      rootsystem$jxl <- as.vector(hydraulics$jxl)\n      rootsystem$psi_soil <- as.vector(hydraulics$psi_soil)\n      \n      mydata <- rootsystem\n      #mydata$length = sqrt((mydata$x1-mydata$x2)^2 + (mydata$y1-mydata$y2)^2 + (mydata$z1-mydata$z2)^2 )\n      mydata$z1 <- round(mydata$z1, 0)\n      dens2 <- ddply(mydata, .(z1), summarise, root = sum(jr))\n      max <- dens2$z1[dens2$root == max(dens2$root)]\n      \n      rs$rootsystem <- rootsystem\n      rs$soil <- soil\n      rs$tact <- hydraulics$tact\n      rs$krs <- hydraulics$krs\n      evol <- rs$evol\n      rs$evol <- rbind(evol, data.frame(krs = hydraulics$krs, tact = hydraulics$tact, udepth=max))\n    })    \n    \n    # Get the click inside the conductivity graph\n    observe({\n      if(is.null(rs$conductivities)){return()}\n      # Because it's a ggplot2, we don't need to supply xvar or yvar; if this\n      # were a base graphics plot, we'd need those.\n      temp <- filter(rs$conductivities, order == input$roottype1)\n      sel <- nearPoints(temp, input$plot1_click)\n      updateTextInput(session, \"x_input\", value=sel$x)\n      updateTextInput(session, \"y_input\", value=sel$y)\n      # paste0(sel$order, \" / \", sel$type)\n    })\n    \n    \n    \n    observeEvent(input$updateCond, {\n      temp <- filter(rs$conductivities, order == input$roottype1)\n      sel <- nearPoints(temp, input$plot1_click)\n      \n      conds <- rs$conductivities\n      rootsystem <- rs$rootsystem\n      \n      conds$x[conds$id == sel$id] <- as.numeric(input$x_input)\n      conds$y[conds$id == sel$id] <- as.numeric(input$y_input)\n\n      \n      hydraulics <- getSUF(rootsystem, conds, rs$soil, Psi_collar = input$psiCollar)\n\n      rootsystem$suf <- as.vector(hydraulics$suf)\n      rootsystem$jr <- as.vector(hydraulics$jr)\n      rootsystem$psi <- as.vector(hydraulics$psi)\n      rootsystem$suf1 <- as.vector(hydraulics$suf1)\n      rootsystem$kx <- hydraulics$kx\n      rootsystem$kr <- hydraulics$kr\n      rootsystem$jxl <- as.vector(hydraulics$jxl)\n      rootsystem$psi_soil <- as.vector(hydraulics$psi_soil)\n      \n      mydata <- rootsystem\n      #mydata$length = sqrt((mydata$x1-mydata$x2)^2 + (mydata$y1-mydata$y2)^2 + (mydata$z1-mydata$z2)^2 )\n      mydata$z1 <- round(mydata$z1, 0)\n      dens2 <- ddply(mydata, .(z1), summarise, root = sum(jr))\n      max <- dens2$z1[dens2$root == max(dens2$root)]\n      \n      print(max)\n      \n      rs$tact <- hydraulics$tact\n      rs$rootsystem <- rootsystem\n      rs$conductivities <- conds\n      rs$krs <- hydraulics$krs\n      rs$evol <- rbind(rs$evol, data.frame(krs = rs$krs, tact = rs$tact, udepth=max))\n    })\n      \n    \n    # For the root paramerers\n    observe({\n      if(is.null(rs$dataset)){return()}\n        dataset <- rs$dataset\n        params <- rs$params\n        \n        sel1 <- input$roottype\n        sel2 <- input$parameter\n        if(grepl(\"Please\", sel1)) sel1 = unique(dataset$name)[1]\n        if(grepl(\"Please\", sel2)) sel2 = unique(params$name)[1]\n        \n        updateSelectInput(session, \"roottype\", choices = unique(dataset$name), selected = sel1)\n        updateSelectInput(session, \"roottype1\", choices = unique(dataset$name), selected = sel1)\n        \n        ps <- unique(dataset$param)#[dataset$name == input$roottype]\n        remove <- c(\"color\", \"successors\", \"successorP\", \"gf\", \"tropism\")\n        ps <- ps[!ps %in% remove]\n        ps <- params$name[params$id %in% ps]\n        updateSelectInput(session, \"parameter\", choices = ps, selected = sel2)\n        \n        \n        current <- round(as.numeric(dataset$val1[dataset$name == input$roottype & dataset$param == params$id[params$name == input$parameter]]), 2)\n        if(length(current) == 0) current <- 0\n        newMin <- 0\n        newMax <- current * 2\n        if(newMax == 0) newMax <- 1\n        updateSliderInput(session, \"value\", value = current, min = newMin, max = newMax, step = current/10)\n\n        current2 <- round(as.numeric(dataset$val2[dataset$name == input$roottype & dataset$param == params$id[params$name == input$parameter]]), 2)\n        current2 <- (current2/current) * 100\n        if(length(current2) == 0) current <- 0\n        updateSliderInput(session, \"stdev\", value = current2, min = 0, max = 50, step = 5)        \n    })\n    \n    \n    output$littTitle <- renderUI( {\n      if(is.null(rs$litt)){return()}\n      strong(rs$litt$title[rs$litt$name == input$dataset])\n    }) \n    \n    output$littAuth <- renderUI( {\n      if(is.null(rs$litt)){return()}\n      rs$litt$author[rs$litt$name == input$dataset]\n    }) \n    \n    output$littRef <- renderUI( {\n      if(is.null(rs$litt)){return()}\n      litt <- rs$litt[rs$litt$name == input$dataset,]\n      paste0(litt$journal, \", \", litt$volume, \", \", litt$pages, \", \", litt$year)\n    })     \n    \n    output$doi <- renderUI( {\n      if(is.null(rs$litt)){return()}\n      litt <- rs$litt\n      link <- paste0(\"http://dx.doi.org/\", litt$doi[litt$name == input$dataset])\n      a(\"View paper\", href=link, target=\"_blank\")\n    }) \n    \n    output$paramTitle <- renderUI( {\n      if(is.null(rs$params)){return()}\n      params <- rs$params\n      params$name[params$name == input$parameter]\n    })     \n    output$paramText <- renderUI( {\n      if(is.null(rs$params)){return()}\n      params <- rs$params\n      params$text[params$name == input$parameter]\n    })  \n    output$plantText <- renderUI( {\n      if(is.null(rs$params)){return()}\n      params <- rs$params\n      params$text[params$name == input$parameter2]\n    })  \n    output$plantTitle <- renderUI( {\n      if(is.null(rs$params)){return()}\n      params <- rs$params\n      params$name[params$name == input$parameter2]\n    })      \n    \n    # For the plant paramerers\n    observe({\n      if(is.null(rs$plant)){return()}\n      dataset <- rs$plant\n      params <- rs$params\n      params <- params[params$id %in% unique(dataset$param),]\n      sel <- input$parameter2\n      if(grepl(\"Please\", sel)) sel = unique(params$param)[1]\n      \n      ps <- unique(dataset$param)\n      ps <- params$name[params$id %in% ps]\n      \n      updateSelectInput(session, \"parameter2\", choices = ps, selected = sel)\n      current <- round(as.numeric(dataset$val1[dataset$param == params$id[params$name == input$parameter2]]), 2)\n      if(length(current) == 0) current <- 0\n      newMin <- 0\n      newMax <- current * 2\n      if(newMax == 0) newMax <- 1\n      updateSliderInput(session, \"value2\", value = current, min = newMin, max = newMax, step = current/10)\n    })    \n\n    \n    #------------------------------------------------------\n    # PROCESS THE DATA\n    \n    \n    observeEvent(input$loadRoot, {\n      \n      #if(is.null(rs$rootsystem)){\n      if(1 == 1){\n        ## READ THE PARAMETER FILE AND STORE THE DATA IN A DATAFRAME\n        if(input$simpleroot){\n          file.copy(from=paste0(\"www/modelparameter/Zea_maize_simple.rparam\"), to=\"www/param.rparam\", overwrite = T)\n          file.copy(from=paste0(\"www/modelparameter/Zea_maize_simple.pparam\"), to=\"www/param.pparam\", overwrite = T)\n        }else{\n          file.copy(from=paste0(\"www/modelparameter/Zea_maize.rparam\"), to=\"www/param.rparam\", overwrite = T)\n          file.copy(from=paste0(\"www/modelparameter/Zea_maize.pparam\"), to=\"www/param.pparam\", overwrite = T)\n        }\n        fileName <- 'www/param.rparam'\n        param <- read_file(fileName)\n        \n        param <- strsplit(param, \"#\")\n        dataset <- NULL\n        for(k in c(2:length(param[[1]]))){\n          spl <- strsplit(param[[1]][k], \"\\n\")\n          type <- \"\"\n          name <- \"\"\n          for(i in c(1:length(spl[[1]]))){\n            temp <- spl[[1]][i]\n            pos <- regexpr(\"//\", temp)\n            if(pos != -1) temp <- substr(temp, 0, pos-1)\n            if(nchar(temp) > 0){\n              temp <- strsplit(temp, \"\\t\")\n              temp2 <- data.frame(\"type\" = character(0), \"name\" = character(0), \n                                  \"param\" = character(0), \"val1\" = numeric(0), \n                                  \"val2\" = numeric(0), \"val3\" = numeric(0), stringsAsFactors = F)\n              \n              if(temp[[1]][1] == \"type\"){ type <- temp[[1]][2]\n              } else if(temp[[1]][1] == \"name\"){ name <- temp[[1]][2]\n              } else if(grepl(\"Param\", temp[[1]][1])){\n              } else if(temp[[1]][1] == \"tropism\") {\n                temp2[[1,3]] <- \"n_tropism\"\n                temp2$val1 <- temp[[1]][3]\n                temp2$type <- type\n                temp2$name <- name\n                dataset <- rbind(dataset, temp2)\n                temp2$param <- \"sigma_tropism\"\n                temp2$val1 <- temp[[1]][4]\n                temp2$type <- type\n                temp2$name <- name\n                dataset <- rbind(dataset, temp2)  \n                temp2$param <- \"tropism\"\n                temp2$val1 <- temp[[1]][2]\n                temp2$type <- type\n                temp2$name <- name\n                dataset <- rbind(dataset, temp2)  \n              } else {\n                for(j in c(1:4)){\n                  temp2[[1,j+2]] <- temp[[1]][j]\n                  temp2$type <- type\n                  temp2$name <- name\n                }\n                dataset <- rbind(dataset, temp2)\n              }\n            }\n          }\n        }        \n        \n  \n        ## READ THE PARAMETER FILE AND STORE THE DATA IN A DATAFRAME\n        fileName <- 'www/param.pparam'\n        data <- read_file(fileName)\n        # READ THE PARAMETER FILE AND STORE THE DATA IN A DATAFRAME\n        plant <- NULL\n        spl <- strsplit(data, \"\\n\")\n        for(i in c(1:length(spl[[1]]))){\n          temp <- spl[[1]][i]\n          if(nchar(temp) > 0){\n            temp <- strsplit(temp, \"\\t\")\n            temp2 <- data.frame( \"param\" = character(0), \"val1\" = numeric(0), stringsAsFactors = F)\n            for(j in c(1:2)){\n              temp2[[1,j]] <- temp[[1]][j]\n            }\n            plant <- rbind(plant, temp2)\n          }\n        }      \n        \n        colnames(plant) <- c(\"param\", \"val1\")      \n        \n        \n        fileName <- 'www/params.txt'\n        params <- read.table(fileName, sep=\"\\t\", stringsAsFactors = F)\n        colnames(params) <- c(\"id\", \"name\", \"text\")            \n  \n        # setwd(\"www/\")\n        if(Sys.info()['sysname'] == \"Darwin\"){\n          system(\"chmod 777 www/a-mac.out\")\n          system(\"www/a-mac.out\")  \n        }else{\n          system(\"chmod 777 www/a.out\")\n          system(\"www/a.out\")  \n        }\n        rootsystem <- fread(\"www/rootsystem.txt\", header = T)\n        # rootsystem2 <- fread(\"www/rootsystem2.txt\", header = T)\n        conductivities <- read_csv(\"www/conductivities.csv\")\n        \n        \n        orders <- unique(conductivities$order)\n        ids <- unique(conductivities$order_id)\n        rootsystem$name <- \"root\"\n        for(o in c(1:length(orders))){\n          rootsystem$name[rootsystem$type == ids[o]] <- orders[o]\n        }\n        \n        \n        first <- rootsystem[rootsystem$node1ID == 0,]\n        nodals_ids <- unique(rootsystem$branchID[rootsystem$type == 4 | rootsystem$type == 5])\n        for(no in nodals_ids){\n          temp <- rootsystem[rootsystem$branchID == no][1]\n          # rootsystem$node1ID[rootsystem$branchID == no][1] <- 0\n          #\n          connection <- data.frame(node1ID = 0,\n                                   node2ID = temp$node1ID,\n                                   branchID = temp$branchID,\n                                   x1 = first$x1, y1 = first$y1, z1 = first$z1,\n                                   x2 = temp$x1, y2 = temp$y1, z2 = temp$z1,\n                                   radius = temp$radius,\n                                   length = sqrt((first$x1-temp$x1)^2 + (first$y1-temp$y1)^2 + (first$z1-temp$z1)^2 ),\n                                   R = 0, G = 0, B = 0,\n                                   time = temp$time,\n                                   type = temp$type,\n                                   name = temp$name)\n          rootsystem <- rbind(rootsystem, connection)\n        }\n        rootsystem <- rootsystem[order(rootsystem$node2ID, decreasing = F),]\n  \n        \n        \n        # setwd(\"../\")\n        \n        soil <- read_csv(\"www/soil.csv\")\n        \n        hydraulics <- getSUF(rootsystem, conductivities, soil, hetero = T, Psi_collar = input$psiCollar)\n        \n  \n        rootsystem$suf <- as.vector(hydraulics$suf)\n        rootsystem$suf1 <- as.vector(hydraulics$suf1)\n        rootsystem$kx <- hydraulics$kx\n        rootsystem$kr <- hydraulics$kr\n        rootsystem$jr <- as.vector(hydraulics$jr)\n        rootsystem$psi <- as.vector(hydraulics$psi)\n        rootsystem$jxl <- as.vector(hydraulics$jxl)\n        rootsystem$psi_soil <- as.vector(hydraulics$psi_soil)\n        \n        mydata <- rootsystem\n        mydata$z1 <- round(mydata$z1, 0)\n        dens2 <- ddply(mydata, .(z1), summarise, root = sum(jr))\n        maxU <- dens2$z1[dens2$root == max(dens2$root)]\n        \n        print(\"----------\")\n        print(maxU)\n        print(\"----------\")\n        \n        rs$conductivities <- conductivities\n        rs$rootsystem <- rootsystem\n        rs$dataset <- dataset\n        rs$plant <- plant\n        rs$params <- params\n        rs$krs <- hydraulics$krs\n        rs$krs_first <- hydraulics$krs\n        rs$tact <- hydraulics$tact\n        rs$tact_first <- hydraulics$tact\n        rs$udepth_first <- maxU\n        rs$soil <- soil\n        rs$evol <- data.frame(krs = rs$krs, tact = rs$tact, udepth=maxU)\n        print(rs$evol)\n      }\n    })\n    \n    \n    \n        \n    observeEvent(input$updateParams, {\n    # observe({\n        \n        if(is.null(rs$dataset)) return()\n      \n        ## READ THE PARAMETER FILE AND STORE THE DATA IN A DATAFRAME\n        dataset <- rs$dataset\n        \n        ## WRITE BACK THE PARAMETERSET\n        \n        params <- rs$params\n        ps <- params$id[params$name == input$parameter]\n        \n        dataset$val1[dataset$name == input$roottype & dataset$param == ps] <- input$value\n        dataset$val2[dataset$name == input$roottype & dataset$param == ps] <- (input$stdev/100) * input$value\n        \n        message((input$stdev/100) * input$value)\n        \n        types <- unique(dataset$type)\n        text <- NULL\n        for(t in types){\n          if(is.null(text)){text <- \"# Parameter set for type\"\n          }else{\n            text <- paste(text, \"# Parameter set for type\", sep=\"\\n\")\n          }\n          \n          temp <- dataset[dataset$type == t,]\n          \n          str <- paste(\"type\", temp$type[1], sep=\"\\t\")\n          text <- paste(text, str, sep=\"\\n\")\n          \n          str <- paste(\"name\", temp$name[1], sep=\"\\t\")\n          text <- paste(text, str, sep=\"\\n\")\n          \n          for(i in c(1:nrow(temp))){\n            if(temp[i, 3] == \"n_tropism\"){\n              str <- paste(\"tropism\", temp[i+2, 4], temp[i, 4], temp[i+1, 4], sep=\"\\t\")\n              text <- paste(text, str, sep=\"\\n\")\n            }else if(temp[i, 3] == \"sigma_tropism\" | temp[i, 3] == \"tropism\"){\n            }else if(temp[i, 3] == \"dx\"){\n              str <- paste(temp[i, 3], temp[i, 4], sep=\"\\t\")\n              text <- paste(text, str, sep=\"\\n\")\n            }else{\n              str <- paste(temp[i, 3], temp[i, 4], temp[i, 5], temp[i, 6], sep=\"\\t\")\n              text <- paste(text, str, sep=\"\\n\")\n            }\n          }\n          \n        }\n        text <- gsub(\"\\tNA\", \"\", text)\n        cat(text, file=\"www/param.rparam\")\n        \n        \n        ## READ THE PARAMETER FILE AND STORE THE DATA IN A DATAFRAME\n        plant <- rs$plant\n        # WRITE THE NEW PARAMETER FILE\n        ps <- params$id[params$name == input$parameter2]\n        plant$val1[plant$param == ps] <- input$value2\n        text <- NULL\n        for(i in c(1:nrow(plant))){\n          str <- paste(plant[i, 1], plant[i, 2], sep=\"\\t\")\n          text <- paste(text, str, sep=\"\\n\")\n        }\n        \n        text <- gsub(\"\\tNA\", \"\", text)\n\n        cat(text, file=\"www/param.pparam\")\n\n        # setwd(\"www/\")\n        if(Sys.info()['sysname'] == \"Darwin\"){\n          system(\"www/a-mac.out\")  \n        }else{\n          system(\"chmod 777 www/a.out\")\n          system(\"www/a.out\")  \n        }        \n        rootsystem <- fread(\"www/rootsystem.txt\", header = T)\n        \n        orders <- unique(rs$conductivities$order)\n        ids <- unique(rs$conductivities$order_id)\n        rootsystem$name <- \"root\"\n        for(o in c(1:length(orders))){\n          rootsystem$name[rootsystem$type == ids[o]] <- orders[o]\n        }\n        \n        \n        first <- rootsystem[rootsystem$node1ID == 0,]\n        nodals_ids <- unique(rootsystem$branchID[rootsystem$type == 4 | rootsystem$type == 5])\n        for(no in nodals_ids){\n          temp <- rootsystem[rootsystem$branchID == no][1]\n          # rootsystem$node1ID[rootsystem$branchID == no][1] <- 0\n          #\n          connection <- data.frame(node1ID = 0,\n                                   node2ID = temp$node1ID,\n                                   branchID = temp$branchID,\n                                   x1 = first$x1, y1 = first$y1, z1 = first$z1,\n                                   x2 = temp$x1, y2 = temp$y1, z2 = temp$z1,\n                                   radius = temp$radius,\n                                   length = sqrt((first$x1-temp$x1)^2 + (first$y1-temp$y1)^2 + (first$z1-temp$z1)^2 ),\n                                   R = 0, G = 0, B = 0,\n                                   time = temp$time,\n                                   type = temp$type,\n                                   name = temp$name)\n          rootsystem <- rbind(rootsystem, connection)\n        }\n        rootsystem <- rootsystem[order(rootsystem$node2ID, decreasing = F),]\n        \n\n        hydraulics <- getSUF(rootsystem, rs$conductivities, rs$soil, Psi_collar = input$psiCollar)\n        \n        rootsystem$suf <- as.vector(hydraulics$suf)\n        rootsystem$suf1 <- as.vector(hydraulics$suf1)\n        rootsystem$kx <- hydraulics$kx\n        rootsystem$kr <- hydraulics$kr\n        rootsystem$jr <- as.vector(hydraulics$jr)\n        rootsystem$psi <- as.vector(hydraulics$psi)\n        rootsystem$jxl <- as.vector(hydraulics$jxl)\n        rootsystem$psi_soil <- as.vector(hydraulics$psi_soil)\n        \n        \n        \n        mydata <- rootsystem\n        #mydata$length = sqrt((mydata$x1-mydata$x2)^2 + (mydata$y1-mydata$y2)^2 + (mydata$z1-mydata$z2)^2 )\n        mydata$z1 <- round(mydata$z1, 0)\n        dens2 <- ddply(mydata, .(z1), summarise, root = sum(jr))\n        max <- dens2$z1[dens2$root == max(dens2$root)]\n        \n        # Read the conductivity file\n        rs$rootsystem <- rootsystem\n        rs$dataset <- dataset\n        rs$plant <- plant\n        rs$krs <- hydraulics$krs\n        rs$tact <- hydraulics$tact\n        evol <- rs$evol\n        rs$evol <- rbind(evol, data.frame(krs = rs$krs, tact = rs$tact, udepth = max))\n    })\n    \n    \n    \n\n    \n    \n    # ----------------------------------------------------------------\n    # PLOT THE ROOT SYSTEM\n    # ----------------------------------------------------------------\n\n    output$rootConductivities <- renderPlot({\n      \n      plot <- ggplot() +  theme_classic()\n      if(is.null(rs$conductivities)){return(plot)}\n      \n      temp <- filter(rs$conductivities, order == input$roottype1) \n      temp$x[temp$x > 50] <- 50\n      \n      pl <- ggplot(temp, aes(x, y, colour=type)) + \n        geom_line(size=2) + \n        geom_point(size = 4) + \n        geom_point(colour=\"white\") +\n        # geom_hline(data=cond_range, aes(yintercept = value)) +\n        theme_classic() + \n        xlab(\"Distance from the tip (cm)\") + \n        ylab(\"Conductivity / conductance\") + \n        facet_grid(type~., scales = \"free\") +\n        theme(text = element_text(size=14),\n              panel.background = element_rect(fill = \"transparent\"), # or theme_blank()\n              plot.background = element_rect(fill = \"transparent\")\n        )\n      pl\n    }, bg=\"transparent\")\n    \n    \n    \n    \n\n    # Plot the evolution between simulations\n    \n    output$evolPlot <- renderPlotly({\n\n      plot <- ggplot() +  theme_classic()\n      if(is.null(rs$evol)){return(plot)}\n\n      temp <- rs$evol\n      temp$id <- c(1:nrow(temp))\n      if(input$chooseEvol == \"krs\"){\n        temp$var <- round(temp[[input$chooseEvol]] / rs$krs_first, 2)\n      }else if(input$chooseEvol == \"tact\"){\n        temp$var <- round(temp[[input$chooseEvol]] / rs$tact_first, 2)\n      }\n      else {\n        temp$var <- round(temp[[input$chooseEvol]] / rs$udepth_first, 2)\n      }\n\n      pl <- ggplot(temp, aes(id, var, colour=id)) +\n        geom_line(colour=\"black\") +\n        geom_point(size=2) +\n        geom_point(size=1, colour=\"white\") +\n        theme_classic() +\n        ylab(\"Value [% first simulation]\") +\n        xlab(\"Simulation\")\n      ggplotly(pl)\n    })\n    \n    \n    #Plot the soil profile    \n    output$soilPlot <- renderPlot({\n      \n      plot <- ggplot() +  theme_classic()\n      if(is.null(rs$soil)){return(plot)}\n      \n      pl <- ggplot(rs$soil, aes(z, psi, colour=psi)) + \n        geom_line(size=2) + \n        geom_point(size = 4) + \n        geom_point(colour=\"white\") +\n        theme_classic() + \n        ylab(\"Soil water potential\") + \n        xlab(\"Depth [cm]\") + \n        coord_flip()+\n        theme(text = element_text(size=14),\n              panel.background = element_rect(fill = \"transparent\"), # or theme_blank()\n              plot.background = element_rect(fill = \"transparent\"),\n              axis.text.x = element_text(angle = 45, hjust = 1)\n        )\n      pl\n    }, bg=\"transparent\")    \n      \n    \n    # Plot the root system\n    \n    output$rootPlot <- renderPlot({\n      \n      plot <- ggplot() +  theme_classic()\n      if(is.null(rs$rootsystem)){return(plot)}\n      \n      mydata <- rs$rootsystem\n\n      mydata <- mydata[mydata$name %in% input$choosetype,]\n      \n      soil <- ddply(mydata, .(round(z2)), summarise, psi = mean(psi_soil))\n      soil$z <- soil[,1]\n      soil$x <- min(mydata$x1) - 5\n      \n      plot <- plot +\n        geom_point(data = soil, aes(x, z, fill=psi), shape=22, size=4, colour=\"white\") + \n        scale_fill_gradientn(colours = cscale3, \n                               name = \"Soil water potential [hPa]\",\n                               limits = range(soil))\n        \n      if(input$plotroottype == 1){\n        plot <- plot + \n        geom_segment(data = mydata, aes(x = x1, y = z1, xend = x2, yend = z2, colour=name), alpha=0.9, size=1.2)\n      \n      }else if(input$plotroottype == 2){\n        plot <- plot + \n          geom_segment(data = mydata, aes(x = x1, y = z1, xend = x2, yend = z2, \n                                          colour=suf), alpha=0.9, size=1.2) +\n          scale_colour_gradientn(colours=rev(heat.colors(10)), \n                                 name = \"Standart uptake fraction [log]\",\n                                 limits = input$sufrange) \n      \n      }else if(input$plotroottype == 3){\n        plot <- plot + \n          geom_segment(data = mydata, aes(x = x1, y = z1, xend = x2, yend = z2, \n                                          colour=psi), alpha=0.9, size=1.2) +\n          scale_colour_gradientn(colours=cscale3, \n                                 name = \"Water potential\",\n                                 limits = input$psirange) \n      \n      }else if(input$plotroottype == 4){\n        plot <- plot + \n          geom_segment(data = mydata, aes(x = x1, y = z1, xend = x2, yend = z2, \n                                          colour=jxl), alpha=0.9, size=1.2) +\n          scale_colour_gradientn(colours=cscale3, \n                                 name = \"Axial fluxes\",\n                                 limits = input$jxlrange) \n      \n      }else if(input$plotroottype == 5){\n        plot <- plot + \n          geom_segment(data = mydata, aes(x = x1, y = z1, xend = x2, yend = z2, \n                                          colour=jr), alpha=0.9, size=1.2) +\n          scale_colour_gradientn(colours=cscale3, \n                                 name = \"Radial fluxes\",\n                                 limits = input$jrrange)         \n      \n      }else if(input$plotroottype == 6){\n        plot <- plot + \n          geom_segment(data = mydata, aes(x = x1, y = z1, xend = x2, yend = z2, \n                                          colour=kr), alpha=0.9, size=1.2) +\n          scale_colour_gradientn(colours=cscale3, \n                                 name = \"Radial conductivity\") \n      \n      }else if(input$plotroottype == 7){\n        plot <- plot + \n          geom_segment(data = mydata, aes(x = x1, y = z1, xend = x2, yend = z2, \n                                          colour=kx), alpha=0.9, size=1.2) +\n          scale_colour_gradientn(colours=cscale3, \n                                 name = \"Axial conductance\") \n      }\n      plot <- plot + coord_fixed() +\n        ylab(\"Depth (cm)\") \n        \n      rs$plot <- plot\n      \n      plot\n    })\n    \n    \n    \n    \n    # ----------------------------------------------------------------\n    # PLOT THE DENSITY\n    # ----------------------------------------------------------------\n    \n    \n    output$densityPlot <- renderPlot({\n      \n      plot <- ggplot() +  theme_classic()\n      if(is.null(rs$rootsystem)){return(plot)}\n      \n      mydata <- rs$rootsystem\n      #mydata$length = sqrt((mydata$x1-mydata$x2)^2 + (mydata$y1-mydata$y2)^2 + (mydata$z1-mydata$z2)^2 )\n      mydata$z1 <- round(mydata$z1, 0)\n      \n      if(input$plotdensitytype == 1){\n        dens <- ddply(mydata, .(z1, name), summarise, root = sum(length))  \n        yl <- \"total root length (cm)\" \n      }else if(input$plotdensitytype == 2){\n        dens <- ddply(mydata, .(z1, name), summarise, root = sum(suf1))\n        yl <- \"standart uptake fraction\"\n      }else if(input$plotdensitytype == 3){\n        dens <- ddply(mydata, .(z1, name), summarise, root = sum(jr))\n        yl <- \"Radial flow\"\n      }else if(input$plotdensitytype == 4){\n        dens <- ddply(mydata, .(z1, name), summarise, root = sum(jxl))\n        yl <- \"Axial flow\"\n      }else if(input$plotdensitytype == 5){\n        dens <- ddply(mydata, .(z1, name), summarise, root = mean(psi))\n        yl <- \"Mean water potential\"\n      }\n      \n      dens2 <- ddply(dens, .(z1), summarise, root = sum(root))\n      max <- dens2$z1[dens2$root == max(dens2$root)]\n      \n      plot1 <- ggplot(data = dens, aes(x = z1, y = root, colour=name)) +  \n        theme_classic() + \n        geom_line(data = dens, aes(x = z1, y = root, colour=name), alpha=0.5) + \n        geom_vline(xintercept = max, lty=2) + \n        stat_smooth(se=F) + \n        coord_flip() +\n        xlab(\"depth (cm)\") +\n        ylab(yl)\n      \n      plot1\n    })    \n    \n    \n    \n    # ----------------------------------------------------------------\n    # Downlaod the parameters\n    # ----------------------------------------------------------------\n    \n    # downloadHandler() takes two arguments, both functions.\n    # The content function is passed a filename as an argument, and\n    #   it should write out data to that filename.\n    output$downloadParams <- downloadHandler(\n      \n      # if(is.null(rs$dataset)){return()}\n      # This function returns a string which tells the client\n      # browser what name to use when saving the file.\n      filename = function() {\n        # paste(input$dataset, input$filetype, sep = \".\")\n        \"param.rparams\"\n      },\n      \n      # This function should write data to a file given to it by\n      # the argument 'file'.\n      content = function(file) {\n\n        dataset <- rs$dataset\n        \n        ## WRITE BACK THE PARAMETERSET\n        \n        dataset$val1[dataset$name == input$roottype & dataset$param == input$parameter] <- input$value\n        \n        types <- unique(dataset$type)\n        \n        text <- NULL\n        for(t in types){\n          if(is.null(text)){text <- \"# Parameter set for type\"\n          }else{\n            text <- paste(text, \"# Parameter set for type\", sep=\"\\n\")\n          }\n          temp <- dataset[dataset$type == t,]\n          \n          str <- paste(\"type\", temp$type[1], sep=\"\\t\")\n          text <- paste(text, str, sep=\"\\n\")\n          \n          str <- paste(\"name\", temp$name[1], sep=\"\\t\")\n          text <- paste(text, str, sep=\"\\n\")\n          \n          for(i in c(1:nrow(temp))){\n            str <- paste(temp[i, 3], temp[i, 4], temp[i, 5], temp[i, 6], sep=\"\\t\")\n            text <- paste(text, str, sep=\"\\n\")\n          }\n          \n        }\n        text <- gsub(\"\\tNA\", \"\", text)\n        cat(text, file=file)        \n        \n      }\n    )\n    \n\n    \n    # ----------------------------------------------------------------\n    # Downlaod the plot\n    # ----------------------------------------------------------------\n    \n    # downloadHandler() takes two arguments, both functions.\n    # The content function is passed a filename as an argument, and\n    #   it should write out data to that filename.\n    output$downloadPlot <- downloadHandler(\n      \n      # if(is.null(rs$dataset)){return()}\n      # This function returns a string which tells the client\n      # browser what name to use when saving the file.\n      filename = function() {\n        # paste(input$dataset, input$filetype, sep = \".\")\n        paste0(input$dataset, \".png\")\n      },\n      \n      # This function should write data to a file given to it by\n      # the argument 'file'.\n      content = function(file) {\n        mydata <- rs$rootsystem\n        \n        # mydata <- rootsystem\n        \n        plot <- ggplot() +  theme_classic() + \n          geom_segment(data = mydata, aes(x = x1, y = z1, xend = x2, yend = z2, colour=factor(type)), alpha=0.9) +\n          # geom_segment(data = mydata, aes(x = x1, y = z1, xend = x2, yend = z2)) + \n          coord_fixed() +\n\n          ylab(\"Depth (cm)\")\n        # ylab(\"\") \n        \n        if(input$bwfig) plot <- plot + scale_colour_grey()\n        \n        plot + ggsave(file, height = 10, width = 10, bg=\"transparent\")\n      }\n    )      \n        \n    # ----------------------------------------------------------------\n    # Downlaod the data\n    # ----------------------------------------------------------------\n    \n    # downloadHandler() takes two arguments, both functions.\n    # The content function is passed a filename as an argument, and\n    #   it should write out data to that filename.\n    output$downloadRSML <- downloadHandler(\n      \n      # if(is.null(rs$dataset)){return()}\n      # This function returns a string which tells the client\n      # browser what name to use when saving the file.\n      filename = function() {\n        # paste(input$dataset, input$filetype, sep = \".\")\n        paste0(input$dataset, \".rsml\")\n      },\n      \n      # This function should write data to a file given to it by\n      # the argument 'file'.\n      content = function(file) {\n        \n        rsml <- read_file(\"www/rootsystem.rsml\")\n        cat(rsml, file=file)\n        \n      }\n    )  \n    \n    # ----------------------------------------------------------------\n    # Downlaod the data\n    # ----------------------------------------------------------------\n    \n    # downloadHandler() takes two arguments, both functions.\n    # The content function is passed a filename as an argument, and\n    #   it should write out data to that filename.\n    output$downloadCSV <- downloadHandler(\n      \n      # if(is.null(rs$dataset)){return()}\n      # This function returns a string which tells the client\n      # browser what name to use when saving the file.\n      filename = function() {\n        # paste(input$dataset, input$filetype, sep = \".\")\n        paste0(input$dataset, \".txt\")\n      },\n      \n      # This function should write data to a file given to it by\n      # the argument 'file'.\n      content = function(file) {\n        \n        rsml <- read_file(\"www/rootsystem.txt\")\n        cat(rsml, file=file)\n        \n      }\n    )  \n    \n    # ----------------------------------------------------------------\n    # Downlaod the data\n    # ----------------------------------------------------------------\n    \n    # downloadHandler() takes two arguments, both functions.\n    # The content function is passed a filename as an argument, and\n    #   it should write out data to that filename.\n    output$downloadVTP <- downloadHandler(\n      \n      # if(is.null(rs$dataset)){return()}\n      # This function returns a string which tells the client\n      # browser what name to use when saving the file.\n      filename = function() {\n        # paste(input$dataset, input$filetype, sep = \".\")\n        paste0(input$dataset, \".vtp\")\n      },\n      \n      # This function should write data to a file given to it by\n      # the argument 'file'.\n      content = function(file) {\n        \n        rsml <- read_file(\"www/rootsystem.vtp\")\n        cat(rsml, file=file)\n        \n      }\n    )\n    \n    \n    output$table_results <- renderTable({\n      if (is.null(rs$rootsystem)) { return()}\n      mydata <- rs$rootsystem\n      mydata$length = sqrt((mydata$x1-mydata$x2)^2 + (mydata$y1-mydata$y2)^2 + (mydata$z1-mydata$z2)^2 )\n      \n      temp <- data.frame(\"Metric\" = character(), \"Value\"=numeric(),\"Unit\" = character(), stringsAsFactors = F)\n      temp[1,] <- c(\"Total root length\", round(sum(mydata$length)), \"[cm]\")\n      temp[2,] <- c(\"Number of roots segments\", length(mydata$length), \"[-]\")\n      temp[3,] <- c(\"Maximal depth\", round(-min(mydata$z1)), \"[cm]\")\n      \n      \n      p1 <- as.numeric(as.character(rs$krs))\n      p1 <- round(p1, regexpr('[1-9]', p1)[[1]]) \n      temp[4,] <- c(\"Krs\", p1, \"[-]\")\n      \n      p1 <- as.numeric(as.character(rs$tact))\n      p1 <- round(p1, regexpr('[1-9]', p1)[[1]]) \n      temp[5,] <- c(\"T_act\", p1, \"[-]\")\n      \n      temp\n    })  \n    \n    \n    \n    \n  }\n)",
    "created" : 1519460139033.000,
    "dirty" : false,
    "encoding" : "UTF-8",
    "folds" : "",
    "hash" : "2139832107",
    "id" : "FFD7EDF",
    "lastKnownWriteTime" : 1521190401,
    "last_content_update" : 1521190401794,
    "path" : "~/Dropbox/science/projects/0_marshal/marshal/server.R",
    "project_path" : "server.R",
    "properties" : {
    },
    "relative_order" : 1,
    "source_on_save" : false,
    "source_window" : "",
    "type" : "r_source"
}